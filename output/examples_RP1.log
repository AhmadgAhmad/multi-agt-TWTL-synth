09/05/2019 09:50:11 PM DEBUG [hold] Prop: A Duration: 1 Negation: False Props: set(['A', 'D'])
09/05/2019 09:50:11 PM DEBUG [eventually] Low: 0 High: 3 DFA: (Hold 1 A )
09/05/2019 09:50:11 PM DEBUG [hold] Prop: D Duration: 1 Negation: False Props: set(['A', 'D'])
09/05/2019 09:50:11 PM DEBUG [eventually] Low: 0 High: 6 DFA: (Hold 1 D )
09/05/2019 09:50:11 PM DEBUG [concatenation] DFA1: (Eventually (Hold 1 A ) 0 3 ) DFA2: (Eventually (Hold 1 D ) 0 6 )
09/05/2019 09:50:11 PM DEBUG [spec] spec: [H^1 A]^[0, 3] * [H^1 D]^[0, 6]
09/05/2019 09:50:11 PM DEBUG [spec] mode: Infinity DFA: 
Name: (Concat (Eventually (Hold 1 A ) 0 3 ) (Eventually (Hold 1 D ) 0 6 ) )
Directed: True
Multi: False
Props: {'A': 1, 'D': 2}
Alphabet: set([0, 1, 2, 3]) 
Initial: [0]
Final: set([4])
Nodes: [(0, {}), (1, {}), (2, {}), (3, {}), (4, {})]
Edges: [(0, 0, {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (0, 1, {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}), (1, 0, {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (1, 2, {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}), (2, 2, {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (2, 3, {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'}), (3, 2, {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (3, 4, {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'})]
		
09/05/2019 09:50:11 PM DEBUG [spec] tree:
 Op: Concatenation Flags[WDF, WWF, UNR]: True True False
 Init: set([0])
 Final: set([4])
 Left:
   Op: Eventually Flags[WDF, WWF, UNR]: True True False
   Init: set([0])
   Final: set([2])
   Left:
     Op: Hold Flags[WDF, WWF, UNR]: True True True
     Init: set([0])
     Final: set([2])
 Right:
   Op: Eventually Flags[WDF, WWF, UNR]: True True False
   Init: set([2])
   Final: set([4])
   Left:
     Op: Hold Flags[WDF, WWF, UNR]: True True True
     Init: set([2])
     Final: set([4])

09/05/2019 09:50:11 PM DEBUG [spec] No of nodes: 5
09/05/2019 09:50:11 PM DEBUG [spec] No of edges: 8
09/05/2019 09:50:11 PM DEBUG alphabet: {'A': 1, 'D': 2}
09/05/2019 09:50:11 PM DEBUG (0, 0): {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}
09/05/2019 09:50:11 PM DEBUG (0, 1): {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}
09/05/2019 09:50:11 PM DEBUG (1, 0): {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}
09/05/2019 09:50:11 PM DEBUG (1, 2): {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}
09/05/2019 09:50:11 PM DEBUG (2, 2): {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}
09/05/2019 09:50:11 PM DEBUG (2, 3): {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'}
09/05/2019 09:50:11 PM DEBUG (3, 2): {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}
09/05/2019 09:50:11 PM DEBUG (3, 4): {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'}
09/05/2019 09:50:11 PM DEBUG 
End of translate


09/05/2019 09:50:11 PM INFO The bound of formula "[H^1 A]^[0, 3] * [H^1 D]^[0, 6]" is (3, 10)!
09/05/2019 09:50:11 PM INFO Translated formula "[H^1 A]^[0, 3] * [H^1 D]^[0, 6]" to infinity DFA of size (5, 8)!
09/05/2019 09:50:11 PM DEBUG 

Start policy computation

09/05/2019 09:50:11 PM DEBUG [extend_ts] TS: (6, 20) ETS:(6, 20)
09/05/2019 09:50:11 PM INFO Constructing product automaton with infinity DFA!
09/05/2019 09:50:11 PM INFO Product automaton size is: (13, 40)
09/05/2019 09:50:11 PM DEBUG ('A', 1) -> [('B', 0), ('Base', 0), ('A', 2)]
09/05/2019 09:50:11 PM DEBUG ('B', 2) -> [('B', 2), ('A', 2), ('C', 2)]
09/05/2019 09:50:11 PM DEBUG ('B', 0) -> [('A', 1), ('C', 0), ('B', 0)]
09/05/2019 09:50:11 PM DEBUG ('D', 4) -> []
09/05/2019 09:50:11 PM DEBUG ('C', 0) -> [('B', 0), ('C', 0), ('D', 0)]
09/05/2019 09:50:11 PM DEBUG ('Base', 2) -> [('E', 2), ('Base', 2), ('A', 2), ('D', 3)]
09/05/2019 09:50:11 PM DEBUG ('D', 0) -> [('Base', 0), ('C', 0), ('D', 0), ('E', 0)]
09/05/2019 09:50:11 PM DEBUG ('C', 2) -> [('B', 2), ('D', 3), ('C', 2)]
09/05/2019 09:50:11 PM DEBUG ('Base', 0) -> [('A', 1), ('Base', 0), ('D', 0), ('E', 0)]
09/05/2019 09:50:11 PM DEBUG ('E', 2) -> [('E', 2), ('Base', 2), ('D', 3)]
09/05/2019 09:50:11 PM DEBUG ('D', 3) -> [('E', 2), ('Base', 2), ('D', 4), ('C', 2)]
09/05/2019 09:50:11 PM DEBUG ('A', 2) -> [('Base', 2), ('B', 2), ('A', 2)]
09/05/2019 09:50:11 PM DEBUG ('E', 0) -> [('Base', 0), ('D', 0), ('E', 0)]
09/05/2019 09:50:54 PM DEBUG [PartialControl] init: set([0]), final: set([2]), constraint: None
09/05/2019 09:50:54 PM DEBUG [PartialControl] init: set([2]), final: set([4]), constraint: None
09/05/2019 09:50:54 PM DEBUG [Cat] accept || -1 >> : (('B', 0), ('A', 1), ('A', 2)) + || -3 >> : (('A', 2), ('Base', 2), ('D', 3), ('D', 4)) ; max(-1, -3)
09/05/2019 09:50:54 PM DEBUG [Cat] accept || 0 >> : (('C', 0), ('B', 0), ('A', 1), ('A', 2)) + || -3 >> : (('A', 2), ('Base', 2), ('D', 3), ('D', 4)) ; max(0, -3)
09/05/2019 09:50:54 PM DEBUG [Cat] accept || 0 >> : (('D', 0), ('Base', 0), ('A', 1), ('A', 2)) + || -3 >> : (('A', 2), ('Base', 2), ('D', 3), ('D', 4)) ; max(0, -3)
09/05/2019 09:50:54 PM DEBUG [Cat] accept || -1 >> : (('Base', 0), ('A', 1), ('A', 2)) + || -3 >> : (('A', 2), ('Base', 2), ('D', 3), ('D', 4)) ; max(-1, -3)
09/05/2019 09:50:54 PM DEBUG [Cat] accept || 0 >> : (('E', 0), ('Base', 0), ('A', 1), ('A', 2)) + || -3 >> : (('A', 2), ('Base', 2), ('D', 3), ('D', 4)) ; max(0, -3)
09/05/2019 09:50:54 PM INFO Max deadline: -1
09/05/2019 09:50:54 PM INFO Generated output word is: [(), ('A',), ('A',), (), ('D',), ('D',)]
09/05/2019 09:50:54 PM INFO Generated control policy is: Base -> 1 -> A -> 1 -> A -> 1 -> Base -> 1 -> D -> 1 -> D
09/05/2019 09:50:54 PM DEBUG [hold] Prop: A Duration: 1 Negation: False Props: set(['A', 'D'])
09/05/2019 09:50:54 PM DEBUG [eventually] Low: 0 High: 3 DFA: (Hold 1 A )
09/05/2019 09:50:54 PM DEBUG [hold] Prop: D Duration: 1 Negation: False Props: set(['A', 'D'])
09/05/2019 09:50:54 PM DEBUG [eventually] Low: 0 High: 6 DFA: (Hold 1 D )
09/05/2019 09:50:54 PM DEBUG [concatenation] DFA1: (Eventually (Hold 1 A ) 0 3 ) DFA2: (Eventually (Hold 1 D ) 0 6 )
09/05/2019 09:50:54 PM DEBUG [spec] spec: [H^1 A]^[0, 3] * [H^1 D]^[0, 6]
09/05/2019 09:50:54 PM DEBUG [spec] mode: Infinity DFA: 
Name: (Concat (Eventually (Hold 1 A ) 0 3 ) (Eventually (Hold 1 D ) 0 6 ) )
Directed: True
Multi: False
Props: {'A': 1, 'D': 2}
Alphabet: set([0, 1, 2, 3]) 
Initial: [0]
Final: set([4])
Nodes: [(0, {}), (1, {}), (2, {}), (3, {}), (4, {})]
Edges: [(0, 0, {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (0, 1, {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}), (1, 0, {'input': set([0, 2]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (1, 2, {'input': set([1, 3]), 'guard': u'A', 'weight': 0, 'label': u'A'}), (2, 2, {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (2, 3, {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'}), (3, 2, {'input': set([0, 1]), 'guard': '(else)', 'weight': 0, 'label': '(else)'}), (3, 4, {'input': set([2, 3]), 'guard': u'D', 'weight': 0, 'label': u'D'})]
		
09/05/2019 09:50:54 PM DEBUG [spec] tree:
 Op: Concatenation Flags[WDF, WWF, UNR]: True True False
 Init: set([0])
 Final: set([4])
 Left:
   Op: Eventually Flags[WDF, WWF, UNR]: True True False
   Init: set([0])
   Final: set([2])
   Left:
     Op: Hold Flags[WDF, WWF, UNR]: True True True
     Init: set([0])
     Final: set([2])
 Right:
   Op: Eventually Flags[WDF, WWF, UNR]: True True False
   Init: set([2])
   Final: set([4])
   Left:
     Op: Hold Flags[WDF, WWF, UNR]: True True True
     Init: set([2])
     Final: set([4])

09/05/2019 09:50:54 PM DEBUG [spec] No of nodes: 5
09/05/2019 09:50:54 PM DEBUG [spec] No of edges: 8
09/05/2019 09:50:54 PM INFO Relaxation is: (-1, [(-1, (0, 3)), (-4, (0, 6))])
